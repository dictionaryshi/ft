分布式系统:把原来用Java开发的一个大系统, 给拆分成多个子系统, 多个子系统之间互相调用, 形成一个大系统的整体。

一个服务的代码不要太多, 服务的拆分先按大的业务进行第一轮拆分, 然后再拆分每一个子业务。

系统拆分如果不用dubbo等RPC框架, 那么可以采用简单的http通信。但是需要自己处理超时重试、负载均衡等问题。

架构演变:
    *单一应用架构:网站流量很小时, 只需一个应用, 将所有功能都部署在一起。
    *垂直应用架构:当访问量逐渐增大, 单一应用增加机器带来的加速度越来越小, 将应用拆成互不相干的几个应用, 以提升效率。(拆分为PC端、APP端、后端)
    *分布式服务架构:当垂直应用越来越多, 应用之间交互不可避免, 将核心业务抽取出来, 作为独立的服务, 逐渐形成稳定的服务中心, 使前端应用能更快速的响应多变的市场需求。
    *流动计算架构:当服务越来越多, 容量的评估, 小服务资源的浪费等问题逐渐显现, 此时需增加一个调度中心基于访问压力实时管理集群容量, 提高集群利用率。

dubbo工作流程:
    0)服务容器负责启动, 加载, 运行服务提供者。
    1)服务提供者在启动时, 向注册中心注册自己提供的服务。
    2)服务消费者在启动时, 向注册中心订阅自己所需的服务。
    3)注册中心返回服务提供者地址列表给消费者, 如果有变更, 注册中心将基于长连接推送变更数据给消费者。
    4)服务消费者, 从提供者地址列表中, 基于软负载均衡算法, 选一台提供者进行调用, 如果调用失败, 再选另一台调用。
    5)服务消费者和提供者, 在内存中累计调用次数和调用时间, 定时每分钟发送一次统计数据到监控中心。

服务提供者和消费者只在启动时与注册中心交互, 所以dubbo注册中心挂了还可以继续通信, 消费者会将提供者的地址等信息拉取到本地缓存, 注册中心不转发请求, 压力较小。
注册中心, 服务提供者, 服务消费者三者之间均为长连接。
注册中心通过长连接感知服务提供者的存在, 服务提供者宕机, 注册中心将立即推送事件通知消费者。

dubbo:缺省协议采用单一长连接和NIO异步通讯, 适合于小数据量大并发的服务调用, 以及服务消费者机器数远大于服务提供者机器数的情况。
反之, dubbo缺省协议不适合传送大数据量的服务, 比如传文件, 传视频等, 除非请求量很低。
    连接个数:单连接。
    连接方式:长连接。
    传输协议:TCP。
    传输方式:NIO异步传输。
    序列化:Hessian二进制序列化。
    适用范围:传入传出参数数据包较小(建议小于100K), 消费者比提供者个数多, 单一消费者无法压满提供者, 尽量不要用dubbo协议传输大文件或超大字符串。
    适用场景:常规远程服务方法调用。
    参数及返回值需实现Serializable接口。

    消费者比提供者个数多的原因:因dubbo协议采用单一长连接, 假设网络为千兆网卡(1024Mbit=128MByte), 根据测试经验数据每条连接最多只能压满7MByte,
    理论上1个服务提供者需要20个服务消费者才能压满网卡。

    为什么不能传大包的原因:因dubbo协议采用单一长连接, 如果每次请求的数据包大小为500KByte, 假设网络为千兆网卡, 每条连接最大7MByte,
    单个服务提供者的TPS(每秒处理事务数)最大为128MByte / 500KByte = 262。单个消费者调用单个服务提供者的TPS(每秒处理事务数)最大为7MByte / 500KByte = 14。
    如果能接受, 可以考虑使用, 否则网络将成为瓶颈。

    为什么采用异步单一长连接的原因:因为服务的现状大都是服务提供者少, 通常只有几台机器, 而服务的消费者多, 可能整个网站都在访问该服务。
    通过单一连接, 保证单一消费者不会压死提供者, 长连接, 减少连接握手验证等, 并使用异步IO, 复用线程池, 防止C10K问题。

dubbo负载均衡策略:
    1)Random LoadBalance
    2)RoundRobin LoadBalance
    3)LeastActive LoadBalance
    4)ConsistentHash LoadBalance

SPI:service provider interface。
Protocol接口, 在系统运行的时候, dubbo会判断一下应该选哪个实现类来实例化。它会去找一个你配置的Protocol实现类, 如果找到, 那么直接使用它。
对很多组件, 都是保留一个接口和多个实现, 然后在系统运行的时候动态根据配置去找到对应的实现类。如果你没配置, 那就走默认的实现好了。

timeout:一般设置为200ms。
retries:一般是在读请求的时候。

幂等:
    1)对于每个请求必须有一个唯一的标识。
    2)每次处理完请求之后, 必须有一个记录标识这个请求处理过了。常见的方案是在mysql中记录个状态。
    3)每次接收请求需要进行判断之前是否处理过。

保证顺序性:使用dubbo的一致性hash负载均衡策略, 然后使用内存队列。

