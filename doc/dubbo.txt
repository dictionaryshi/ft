分布式系统:把原来用Java开发的一个大块系统, 给拆分成多个子系统, 多个子系统之间互相调用, 形成一个大系统的整体。

一个服务的代码不要太多, 1万行左右, 两三万撑死了。

dubbo分层:
    1)service层:服务提供的具体实现。
    2)config:配置层, dubbo的详细配置。
    3)proxy:服务代理层, 为consumer和provider生成代理, 代理之间进行通信。
    4)registry:注册中心层, 负责服务的注册与发现。
    5)cluster:路由层, 封装多个服务提供者的路由以及负载均衡。
    6)monitor:监控层, RPC 调用次数和调用时间监控。
    7)protocol:远程调用层, 封装rpc调用。
    8)exchange:信息交换层, 封装请求响应模式, 同步转异步。
    9)transport:网络传输层, 抽象mina和netty为统一接口。
    10)serialize:数据序列化层。

dubbo工作流程:
    1)provider向注册中心去注册。
    2)consumer从注册中心订阅服务, 注册中心会通知consumer注册好的服务。
    3)consumer调用provider。
    4)consumer和provider都异步通知监控中心。

dubbo注册中心挂了还可以继续通信, 因为开始初始化的时候, 消费者会将提供者的地址等信息拉取到本地缓存。

dubbo通信协议:
    1)dubbo协议:默认协议。单一长连接, 进行的是NIO异步通信, 基于hessian作为序列化协议。使用的场景是:传输数据量小(每次请求在100kb以内), 但是并发量很高。

为了要支持高并发场景, 一般是服务提供者就几台机器, 但是服务消费者有上百台, 可能每天调用量达到上亿次, 此时用长连接是最合适的, 就是跟每个服务消费者维持一个长连接就可以。
可能总共就100个连接。然后后面直接基于长连接NIO异步通信, 可以支撑高并发请求。

dubbo负载均衡策略:
    1)random loadbalance:默认策略。可以对provider不同实例设置不同的权重, 会按照权重来负载均衡, 权重越大分配流量越高, 一般就用这个默认的就可以了。
    2)roundrobin loadbalance:均匀地将流量打到各个机器上去, 但是如果各个机器的性能不一样, 容易导致性能差的机器负载过高。
    所以此时需要调整权重, 让性能差的机器承载权重小一些, 流量少一些。(解决机器配置低)
    3)leastactive loadbalance:最小活跃数负载均衡。
    4)consistanthash loadbalance:相同参数的请求一定分发到一个provider上去, provider挂掉的时候, 会基于虚拟节点均匀分配剩余的流量, 抖动不会太大。

SPI:service provider interface。
Protocol接口, 在系统运行的时候, dubbo会判断一下应该选哪个实现类来实例化。它会去找一个你配置的Protocol实现类, 如果找到, 那么直接使用它。
对很多组件, 都是保留一个接口和多个实现, 然后在系统运行的时候动态根据配置去找到对应的实现类。如果你没配置, 那就走默认的实现好了。

timeout:一般设置为200ms。
retries:一般是在读请求的时候。

幂等:
    1)对于每个请求必须有一个唯一的标识。
    2)每次处理完请求之后, 必须有一个记录标识这个请求处理过了。常见的方案是在mysql中记录个状态。
    3)每次接收请求需要进行判断之前是否处理过。

保证顺序性:使用dubbo的一致性hash负载均衡策略, 然后使用内存队列。

