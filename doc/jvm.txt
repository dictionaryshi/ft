jstack 4941 | \
grep "\"" | \
awk -F "\"" '{print $2}' | \
awk -F "-" '{if (NF > 1) {line = ""; i = 1; while (i < NF) {line = (line "" $i); i++;}; print line} else {print $0}}' | \
uniq -c | sort -nr

// 打印16进制
printf "%x\n" 15

// 查看进程内线程使用情况
top -H -p 4941
ps -mp 进程号 -o THREAD,tid,time
jstack 6772 | grep 1abc -A 100

// 查看java进程
jps -l

// 查看java启动参数
jinfo -flags 17346

jinfo -flag MaxMetaspaceSize 17346
jinfo -flag InitialHeapSize 17346
jinfo -flag MaxHeapSize 17346
jinfo -flag NewSize 17346
jinfo -flag OldSize 17346

-Xms256m (默认物理内存1 / 64)
-Xmx256m (默认物理内存1 / 4)

查看linux系统负载:uptime

vmstat -n 2 3 (每两秒采样一次, 共采样3次)
    -procs:
        1)r:代表CPU运行队列中的进程数。整个系统CPU运行队列中进程数不能超过总CPU核数的2倍, 否则代表系统压力过大。
        2)b:代表被阻塞的进程数。(IO操作等)
    -cpu:
        1)us:us值比较高时, 说明用户进程消耗的CPU时间较多, 如果长期大于50%, 需要考虑优化应用程序。
        2)sy:sy值比较高时, 说明系统进程消耗的CPU时间较多, 如果us + sy超过80%, 就表明CPU资源存在不足。

mpstat -P ALL 2
pidstat -u 2 -p 进程号
pidstat -r 2 -p 进程号

jvm的区域划分:程序计数器、虚拟机栈、堆、方法区、本地方法栈。
    1)程序计数器:每个线程都有一个程序计数器, 是一块较小的内存空间, 记录字节码指令的地址。多线程情况下, 程序计数器记录的是当前线程执行的位置。
    2)Java虚拟机栈:每个线程都有自己的Java虚拟机栈, 如果线程执行了一个方法, 那么就会为这个方法调用创建对应的一个栈帧,
    栈帧里就有这个方法的局部变量表、操作数栈等数据。
    3)Java堆内存:存放对象。字符串常量池。(线程共享, 新生代、老年代)
    4)方法区/Metaspace:已经被虚拟机加载的类信息, 静态变量, 常量, 即时编译器编译后的代码。(线程共享, 永久代)
    当类被Java虚拟机加载后, .class文件中的常量就存放在方法区的运行时常量池中。
    5)本地方法栈:本地方法运行过程的内存模型, 为JVM运行Native方法准备的空间。

JDK1.8同JDK1.7比, 元数据区取代了永久代。元数据空间并不在虚拟机中, 而是使用本地内存。

方法压栈出栈的过程:当方法运行过程中需要创建局部变量时, 就将局部变量的值存入栈帧中的局部变量表中。
Java虚拟机栈的栈顶的栈帧是当前正在执行的活动栈, 也就是当前正在执行的方法, PC寄存器也会指向这个地址。
只有这个活动的栈帧的本地变量可以被操作数栈使用, 当在这个栈帧中调用另一个方法, 与之对应的栈帧又会被创建, 新创建的栈帧压入栈顶, 变为当前的活动栈帧。
方法结束后, 当前栈帧被移出, 栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值, 那么新的活动栈帧中操作数栈的操作数没有变化。

类加载器把class文件中的二进制数据读入到内存中, 存放在方法区, 然后在堆区创建一个java.lang.Class对象, 用来封装类在方法区内的数据结构。
    加载:查找并加载类的二进制数据(把class文件里面的信息加载到内存里面)。
    连接:把内存中类的二进制数据合并到虚拟机的运行时环境中。
        1)验证:确保被加载的类的正确性。
            a.类文件的结构检查:检查是否满足Java类文件的固定格式。
            b.语义检查:确保类本身符合Java的语法规范。
            c.字节码验证:确保字节码流可以被Java虚拟机安全的执行。
        2)准备:为类的静态变量分配内存, 并将其初始化为默认值。
        3)解析:把类中的符号引用转化为直接引用。(方法符号引用是由方法名和相关描述符组成, 解析阶段将符号引用替换成指针)
    初始化:为类的静态变量赋予正确的初始值。执行static块再次初始化。

