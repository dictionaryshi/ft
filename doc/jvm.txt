jstack 4941 | \
grep "\"" | \
awk -F "\"" '{print $2}' | \
awk -F "-" '{if (NF > 1) {line = ""; i = 1; while (i < NF) {line = (line "" $i); i++;}; print line} else {print $0}}' | \
uniq -c | sort -nr

// 打印16进制
printf "%x\n" 15

// 查看进程内线程使用情况
top -H -p 4941
ps -mp 进程号 -o THREAD,tid,time
jstack 6772 | grep 1abc -A 100

// 查看java进程
jps -l

// 查看java启动参数
jinfo -flags 17346

jinfo -flag MaxMetaspaceSize 17346
jinfo -flag InitialHeapSize 17346
jinfo -flag MaxHeapSize 17346
jinfo -flag NewSize 17346
jinfo -flag OldSize 17346

-Xms256m (默认物理内存1 / 64)
-Xmx256m (默认物理内存1 / 4)

查看linux系统负载:uptime

vmstat -n 2 3 (每两秒采样一次, 共采样3次)
    -procs:
        1)r:代表CPU运行队列中的进程数。整个系统CPU运行队列中进程数不能超过总CPU核数的2倍, 否则代表系统压力过大。
        2)b:代表被阻塞的进程数。(IO操作等)
    -cpu:
        1)us:us值比较高时, 说明用户进程消耗的CPU时间较多, 如果长期大于50%, 需要考虑优化应用程序。
        2)sy:sy值比较高时, 说明系统进程消耗的CPU时间较多, 如果us + sy超过80%, 就表明CPU资源存在不足。

mpstat -P ALL 2
pidstat -u 2 -p 进程号
pidstat -r 2 -p 进程号

jvm的区域划分:程序计数器、虚拟机栈、堆、方法区、本地方法栈。
    1)程序计数器:每个线程都有一个程序计数器, 专门记录当前线程目前执行到了哪一条字节码指令。
    2)Java虚拟机栈:每个线程都有自己的Java虚拟机栈, 如果线程执行了一个方法, 那么就会为这个方法调用创建对应的一个栈帧,
    栈帧里就有这个方法的局部变量表、操作数栈等数据。
    3)Java堆内存:存放对象。字符串常量池。
    4)方法区/Metaspace:类信息, 方法信息, 其它常量池。
    5)本地方法栈:native用到的相关信息。

类加载器把class文件中的二进制数据读入到内存中, 存放在方法区, 然后在堆区创建一个java.lang.Class对象, 用来封装类在方法区内的数据结构。
    加载:查找并加载类的二进制数据(把class文件里面的信息加载到内存里面)。
    连接:把内存中类的二进制数据合并到虚拟机的运行时环境中。
        1)验证:确保被加载的类的正确性。
            a.类文件的结构检查:检查是否满足Java类文件的固定格式。
            b.语义检查:确保类本身符合Java的语法规范。
            c.字节码验证:确保字节码流可以被Java虚拟机安全的执行。
        2)准备:为类的静态变量分配内存, 并将其初始化为默认值。
        3)解析:把类中的符号引用转化为直接引用。(方法符号引用是由方法名和相关描述符组成, 解析阶段将符号引用替换成指针)
    初始化:为类的静态变量赋予正确的初始值。执行static块再次初始化。

