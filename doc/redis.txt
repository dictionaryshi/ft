1.cd /opt

2.mkdir redis

3.tar -zxvf redis-3.0.7.tar.gz

4.yum install -y gcc

5.cd /opt/redis/redis-3.0.7

6.make (如果出错make distclean)

7.make install

1.事务特性:A(原子性), C(一致性), I(隔离性), D(持久性)。

2.C(强一致性), A(高可用性), P(分区容错性)。

3.Redis:高性能的(key/value)分布式内存数据库。

    ./redis-cli -p 6379

    ping

    SHUTDOWN  (关闭redis服务器)

    exit (退出客户端)

./redis-benchmark (测试读写性能)

4.RDB:

    1)在指定的时间间隔内将内存中的数据集快照(Snapshot快照)写入磁盘,
    它恢复时是将快照文件直接读到内存里。

    2)Redis会单独fork一个子进程来进行持久化, 会先将数据写入到一个临时文件中, 待持久化过程都结束了, 再用这个临时文件替换上次持久化好的文件。
    整个过程中, 主进程是不进行任何IO操作的, 如果需要进行大规模数据的恢复, 且对于数据恢复的完整性不是非常敏感,那RDB方式要比AOF方式更加的高效。(fork的作用是复制一个与当前进程一样的进程。
    新进程的所有数据数值都和原进程一致, 并作为原进程的子进程)

    3)RDB的缺点是最后一次持久化后的数据可能丢失(意外宕机等等)。还有fork会产生2倍的内存膨胀空间, 并且大数据集fork也是非常耗时的。

    RDB默认频率:

        save 900 1     //十五分钟内改变一次
        save 300 10   //五分钟改变10次
        save 60 10000 // 一分钟改变1万次

    6)手动调用RDB备份==>BGSAVE

5.AOF:

    1)以日志的形式来记录每个写操作, 将Redis执行过的所有写指令记录下来(读操作不记录),
    redis重启时就会根据日志文件的内容将写指令从前到后执行一次以完成数据恢复工作。

    2)redis默认关闭AOF的功能。开启:

        appendonly yes

    3)RDB AOF的默认生成文件分别是:dump.rdb, appendonly.aof。(生成目录==>config get dir)

    4)AOF和RDB可以共存, AOF的优先级更高(恢复数据时, 有AOF就不走RDB了)

    5)若AOF文件所怀可以尝试修复==> # redis-check-aof --fix appendonly.aof

    6)appendfsync everysec 异步写入AOF(频率:每秒)效率较好。

      appendfsync always 发生数据改变会立即写进磁盘, 性能较差。数据完整性会更好。

    7)对于相同数据集的数据而言aof文件要远大于rdb文件, 恢复速度慢于rdb。
    AOF数据完整性保存较好, 但是频繁IO是它的致命问题, 所以被主从复制取代。

6.性能建议:

    1)因为RDB文件只用作后备用途,建议只在Slave上持久化RDB文件,
    而且只要15分钟备份一次就够了,只保留save 900 1这条规则。

    2)如果不Enable AOF, 仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO, 也减少了rewrite时带来的系统波动。
    代价是如果Master/Slave同时宕掉, 会丢失十几分钟的数据, 启动脚本也要比较两个Master/Slave中的RDB文件, 载入较新的那个。

使用缓存的原因:高性能、高并发。(Mysql的QPS较低, 不适合高并发)

redis高效:纯内存操作、核心是基于非阻塞的IO多路复用机制、单线程避免了多线程的频繁上下文切换问题。

redis过期策略:定期删除 + 惰性删除。
    1)定期删除:redis默认是每隔100ms就随机抽取一些设置了过期时间的key, 检查其是否过期, 如果过期就删除。
    2)惰性删除:获取某个key的时候, redis会检查一下这个key, 如果设置了过期时间并且过期了就会删除, 不会返回任何东西。

redis内存淘汰机制:
    1)noeviction:当内存不足以容纳新写入数据时, 新写入操作会报错。
    2)allkeys-lru:当内存不足以容纳新写入数据时, 在键空间中, 移除最近最少使用的key。
    3)allkeys-random:当内存不足以容纳新写入数据时, 在键空间中, 随机移除某个key。
    4)volatile-lru:当内存不足以容纳新写入数据时, 在设置了过期时间的键空间中, 移除最近最少使用的key。
    5)volatile-random:当内存不足以容纳新写入数据时, 在设置了过期时间的键空间中, 随机移除某个key。
    6)volatile-ttl:当内存不足以容纳新写入数据时, 在设置了过期时间的键空间中, 有更早过期时间的key优先移除。

