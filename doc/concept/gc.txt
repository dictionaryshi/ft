1.对象的生命周期不同, 所以针对不同生命周期的对象可以采取不同的回收方式, 以便提高回收效率。(分代回收)

2.JVM堆内存主要由新生代、老年代、永久代构成。

3.新生代:对象在新生代中被创建, 其中很多对象的生命周期很短。每次新生代的垃圾回收(又称Minor GC)后只有少量对象存活, 所以选用复制算法。只需要少量的复制成本就可以完成回收。

4.新生代又分为三个区:一个Eden区, 两个Survivor区(一个Eden区和一个Survivor区默认比例是8:1, 仅10%的内存处于闲置状态)。
复制算法的优点:消灭内存碎片。Eden区的加入同时提高了内存使用率。

5.对象在Eden区中被创建, 当Eden区满时(发生Minor GC), 还存活的对象将被复制到两个Survivor区中的一个(From区)。当Eden区再次满时, Eden区存活的对象和From区的存活且不满足"晋升"条件的对象
将被复制到另外一个Survivor区(To)。

6.对象每经历一次Minor GC, 年龄加1, 达到"晋升年龄阈值"后, 被放到老年代。"晋升年龄阈值"的大小直接影响着对象在新生代中的停留时间。(默认值为15, -XX:MaxTenuringThreshold=15)
动态年龄计算:Hotspot遍历所有对象时, 按照年龄从小到大对其所占用的大小进行累积, 当累积的某个年龄大小超过了from survivor区的一半时,
取这个年龄和MaxTenuringThreshold中更小的一个值, 作为新的晋升年龄阈值。

大对象直接进入老年代:-XX:PretenureSizeThreshold。(控制直接进入老年代的对象的大小)

Eden区满时, 进行Minor GC, 当Eden和一个Survivor区中依然存活的对象无法放入到To Survivor中时, 则通过分配担保机制提前转移到老年代中。

老年代空间分配担保规则:在执行任何一次Minor GC之前, JVM会先检查一下老年代可用的内存空间, 是否大于新生代所有对象的总大小。
因为最极端的情况下, 可能新生代Minor GC过后, 所有对象都存活下来了, 可能全部进入老年代。
如果说发现老年代的内存大小是大于新生代所有对象的, 此时就可以放心大胆的对新生代发起一次Minor GC了,
因为即使Minor GC之后所有对象都存活, Survivor区放不下了, 也可以转移到老年代去。
但是假如执行Minor GC之前, 发现老年代的可用内存已经小于了新生代的全部对象大小了, 就会看"-XX:-HandlePromotionFailure"参数是否设置了。
如果设置了, 那么看看老年代的内存大小, 是否大于之前每一次Minor GC后进入老年代的对象的平均大小。
如果否, 或者没有设置"-XX:-HandlePromotionFailure", 此时会先进行Full GC, 然后再进行Minor GC。
如果是, 那么就是说可以冒点风险尝试一下Minor GC, Minor GC过后, 剩余的存活对象的大小, 是小于Survivor区的大小的, 那么此时存活对象进入Survivor区域即可。
Minor GC过后, 剩余的存活对象的大小, 是大于Survivor区域的大小, 但是是小于老年代可用内存大小的, 此时就直接进入老年代即可。
Minor GC过后, 剩余的存活对象的大小, 大于了Survivor区域的大小, 也大于了老年代可用内存的大小。此时老年代都放不下这些存活对象了, 就会发生"Handle Promotion Failure"的情况,
这个时候就会触发一次"Full GC"。
如果要是Full GC过后, 老年代还是没有足够的空间存放Minor GC过后的剩余存活对象, 那么此时就会导致所谓的"OOM"内存溢出了。

7.老年代:在新生代中经历了N次垃圾回收后仍然存活的对象, 就会被放到年老代, 该区域中对象存活率高。

8.老年代的垃圾回收(Major GC)通常使用"标记-清理"或"标记-整理"算法。

9.整堆包括新生代和老年代的垃圾回收称为Full GC。HotSpot VM里, 除了CMS之外, 其它能收集老年代的GC都会同时收集整个GC堆。

10.CMS回收器是一种以获取最短回收停顿时间为目标的回收器, 该回收器是基于"标记-清除"算法实现的。

11.活跃数据的大小是指, 应用程序稳定运行时长期存活对象在堆中占用的空间大小, 也就是Full GC后堆中老年代占用空间的大小。
    堆总大小==> 活跃数据 * 4倍
    年轻代==> 活跃数据 * 1.5倍
    老年代==> 总大小 - 年轻代

12.单次Minor GC时间更多取决于GC后存活对象的数量, 而非Eden区的大小。

13.如果应用存在大量的短期对象, 应该选择较大的年轻代。如果存在相对较多的持久对象, 老年代应该适当增大。

14.由于跨代引用的存在, CMS在Remark阶段必须扫描整个堆, 同时为了避免扫描时新生代有很多对象, 增加了可中断的预清理阶段用来等待Minor GC的发生。
只是该阶段有时间限制, 如果超时等不到Minor GC, Remark时新生代仍然有很多对象, 我们的调优策略是, 通过参数强制Remark前进行一次Minor GC, 从而降低Remark阶段的时间。

15.触发STW的Full GC:
    1)Perm空间不足(CMS默认情况下不会回收Perm区)

    2)老年代空间不足, 需要尽快回收老年代里面的不再被使用的对象。(CMS执行时, 仍会有对象进入老年代, 若老年代空间不足, 则CMS失败)

    3)主动触发Full GC

    4)统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间。

16.CMS(并发标记清除)的四个主要阶段:
    1)Init-mark初始标记(STW):该阶段进行可达性分析, 标记GC ROOT能直接关联到的对象, 所以很快。(单线程)
    2)Concurrent-mark并发标记:由前阶段标记过的对象出发, 所有可到达的对象都在本阶段中标记。
    3)Remark重标记(STW):暂停所有用户线程, 重新扫描堆中的对象, 进行可达性分析, 标记活着的对象。
    因为并发标记阶段是和用户线程并发执行的过程, 所以该过程中可能有用户线程修改某些活跃对象的字段, 指向了一个未标记过的对象。(在并发标记开始时不可达, 但是并行期间引用发生变化, 变为对象可达)
    这个阶段需要重新标记出这一类对象, 防止在下一阶段被清理掉, 这个过程也是需要STW的。特别需要注意一点, 这个阶段是以新生代中对象为根来判断对象是否存活的。
    4)并发清理, 进行并发的垃圾清理。

-XX:CMSInitiatingOccupancyFraction:老年代使用占比为多少时, 触发CMS GC。
-XX:+UseCMSCompactAtFullCollection:FULL GC后进行内存碎片整理。
Concurrent Mode Failure:CMS失败。

GC ROOTS:
    1)栈中局部变量引用的对象。
    2)方法区中的类静态属性引用的对象。
    3)方法区中常量引用的对象。
    4)JNI(本地方法栈)引用的对象。

垃圾回收器:
    1)-XX:+UseSerialGC:串行垃圾回收器。(年轻代/老年代垃圾回收器, 是单线程垃圾回收器, 老年代使用标整算法)
    2)-XX:+UseParNewGC:多线程并行年轻代垃圾回收器。(追求降低用户停顿时间) 使用-XX:ParallelGCThreads来调整线程数量。
    3)-XX:+UseParallelGC:多线程并行年轻代垃圾回收器。侧重于吞吐量。高效利用CPU, 适合后台运算。
    4)-XX:+UseParallelOldGC:多线程并行老年代垃圾回收器。侧重于吞吐量。高效利用CPU, 适合后台运算。
    5)-XX:+UseConcMarkSweepGC:并发标记清除老年代垃圾回收器。侧重短暂停顿。(CPU负担较大, CMS必须在老年代耗尽之前完成, 否则CMS失败将切换为SerialGC)
    CMS无法整理内存碎片, 往往老年代还有很大剩余空间, 但无法找到足够大的连续空间来分配给当前对象, 不得不触发一次Full GC来整理内存碎片。

CPU吞吐量 = 运行代码时间 / (运行代码时间 + 垃圾收集时间)

可达性分析法:所有和GC Roots直接或间接关联的对象都是有效对象。其它对象可以回收。

若Full GC后, 内存仍然不足, 则java.lang.OutOfMemoryError: Java heap space。

新生代内存调优:尽量让Minor GC后的存活对象可以在Survivor区放下。

开启G1垃圾回收器:-XX:+UseG1GC。

G1垃圾回收器既可以回收新生代也可以回收老年代。把Java堆内存拆分为多个大小相等的Region。

G1可以做到让你来设定垃圾回收对系统的影响, 他自己通过把内存拆分为大量小Region, 以及追踪每个Region中可以回收的对象大小和预估时间, 最后在垃圾回收的时候,
尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内, 同时在有限的时间内尽量回收尽可能多的垃圾对象。

在G1对应的内存模型中, 新生代和老年代各自的内存区域是不停的变动的, 由G1自动控制(Region在新生代和老年代之间做转换), 所以没有所谓新生代给多少内存, 老年代给多少内存这一说了。

JVM最多可以有2048个Region, Region的大小必须是2的幂(1, 2, 4, 8, ...)。

手动设置region大小:-XX:G1HeapRegionSize。

比如说堆大小是4G, 那么就是4096MB, 此时除以2048个Region, 每个Region的大小就是2MB。
刚开始的时候, 默认新生代对堆内存的占比是5%, 也就是占据200MB左右的内存, 对应大概是100个Region, 这个是可以通过"-XX:G1NewSizePercent"来设置新生代初始占比的。
JVM其实会不停的给新生代增加更多的Region, 但是最多新生代的占比不会超过60%(-XX:G1MaxNewSizePercent)。
一旦Region进行了垃圾回收, 此时新生代的Region数量还会减少。(动态变化)
新生代有100个Region, 那么可能80个Region就是Eden, 两个Survivor各自占10个Region。

G1的新生代垃圾回收:随着不停的在新生代的Eden对应的Region中放对象, JVM就会不停的给新生代加入更多的Region, 直到新生代占据堆大小的最大比例60%。
新生代占据1200个Region, 里面的Eden可能占据了1000个Region, 每个Survivor是100个Region, 而且Eden区还占满了对象。这个时候还是会触发新生代的GC,
使用复制算法, 进入Stop the World状态。然后把Eden对应的Region中的存活对象放入S1对应的Region中, 接着回收掉Eden对应的Region中的垃圾对象。
因为G1是可以设定目标GC停顿时间的(-XX:MaxGCPauseMillis, 默认值是200ms), G1会对每个Region追踪回收他需要多少时间, 可以回收多少对象来选择回收一部分的Region,
保证GC停顿时间控制在指定范围内, 尽可能多的回收掉一些对象。

g1新生代进入老年代:
    1)对象在新生代躲过了很多次的垃圾回收, 达到了一定的年龄了(-XX:MaxTenuringThreshold), 他就会进入老年代。
    2)动态年龄判定规则, 如果一旦发现某次新生代GC过后, 存活对象超过了Survivor的50%, 比如年龄为1岁, 2岁, 3岁, 4岁的对象的大小总和超过了Survivor的50%,
    此时4岁以上的对象全部会进入老年代。
    3)存活对象在Survivor放不下了。

G1提供了专门的Region来存放大对象, 而不是让大对象进入老年代的Region中。
在G1中, 大对象的判定规则就是一个大对象超过了一个Region大小的50%, 比如每个Region是2MB, 只要一个大对象超过了1MB, 就会被放入大对象专门的Region中
而且一个大对象如果太大, 可能会横跨多个Region来存放。
新生代、老年代在回收的时候, 会顺带带着大对象Region一起回收。

"-XX:InitiatingHeapOccupancyPercent"默认值是45%, 如果老年代占据了堆内存的45%的Region的时候, 此时就会尝试触发一个新生代 + 老年代一起回收的混合回收阶段。
堆内存有2048个Region, 如果老年代占据了其中45%的Region, 也就是接近1000个Region的时候, 就会开始触发一个混合回收。

G1垃圾回收的过程:
    1)首先会触发一个"初始标记"的操作, 这个过程是需要进入"Stop the World"的, 仅仅只是标记一下GC Roots直接能引用的对象, 这个过程速度是很快的。
    先停止系统程序的运行, 然后对各个线程栈内存中的局部变量代表的GC Roots, 以及方法区中的类静态变量代表的GC Roots, 进行扫描, 标记出来他们直接引用的那些对象。
    2)接着会进入"并发标记"的阶段, 这个阶段会允许系统程序的运行, 同时进行GC Roots追踪, 从GC Roots开始追踪所有的存活对象。
    这个并发标记阶段还是很耗时的, 因为要追踪全部的存活对象。但是这个阶段是可以跟系统程序并发运行的, 所以对系统程序的影响不太大。
    JVM会对并发标记阶段对对象做出的一些修改记录起来。
    3)接着是下一个阶段, 最终标记阶段, 这个阶段会进入"Stop the World", 系统程序是禁止运行的, 但是会根据并发标记阶段记录的那些对象修改,
    最终标记一下有哪些存活对象, 有哪些是垃圾对象。
    4)最后一个阶段, 就是"混合回收"阶段, 这个阶段会计算老年代中每个Region中的存活对象数量, 存活对象的占比, 还有执行垃圾回收的预期性能和效率。
    接着会停止系统程序, 然后全力以赴尽快进行垃圾回收, 此时会选择部分Region进行回收, 因为必须让垃圾回收的停顿时间控制在我们指定的范围内。
    比如说老年代此时有1000个Region都满了, 但是因为根据预定目标, 本次垃圾回收可能只能停顿200毫秒, 那么通过之前的计算得知,
    可能回收其中800个Region刚好需要200ms, 那么就只会回收800个Region, 把GC导致的停顿时间控制在我们指定的范围内。

混合回收:回收老年代, 还会回收新生代, 还会回收大对象。
因为我们设定了对GC停顿时间的目标, 所以说他会从新生代、老年代、大对象里各自挑选一些Region, 保证用指定的时间(比如200ms)回收尽可能多的垃圾,
这就是所谓的混合回收。

"混合回收"阶段, 会进入"Stop the World", G1是允许执行多次混合回收的。
比如先停止工作, 执行一次混合回收回收掉一些Region, 接着恢复系统运行, 然后再次停止系统运行, 再执行一次混合回收回收掉一些Region。
"-XX:G1MixedGCCountTarget"控制最后一个阶段执行几次混合回收, 默认值是8次。

在混合回收的时候, 对Region回收都是基于复制算法进行的, 都是把要回收的Region里的存活对象放入其他Region, 然后这个Region中的垃圾对象全部清理掉。
这样的话在回收过程就会不断空出来新的Region, 一旦空闲出来的Region数量达到了堆内存的5%(-XX:G1HeapWastePercent), 此时就会立即停止混合回收, 意味着本次混合回收就结束了。

G1整体是基于复制算法进行Region垃圾回收的, 不会出现内存碎片的问题, 不需要像CMS那样标记-清理之后, 再进行内存碎片的整理。

确定要回收的Region的时候, Region中的存活对象必须低于85%(-XX:G1MixedGCLiveThresholdPercent)才可以进行回收。
85%的对象都拷贝到别的Region, 这个成本是很高的。

如果在进行Mixed回收的时候, 无论是年轻代还是老年代都基于复制算法进行回收, 都要把各个Region的存活对象拷贝到别的Region里去。
此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了, 就会触发一次失败(SerialGC, FULL GC)。

G1会根据你预设的gc停顿时间, 动态给新生代分配一些Region, 然后到一定程度就触发gc, 并且把gc时间控制在预设范围内, 尽量避免一次性回收过多的Region导致gc停顿时间超出预期。

JVM优化思路:GC的频率不能太高, GC的时间不能太长。

G1非常适合大内存机器。

-XX:MaxGCPauseMillis太小容易造成回收频繁, 影响系统的吞吐量。太大会增大系统的停顿时间, 影响用户体验。

Young GC一般不会对系统造成影响, 若Young GC过慢则应该使用G1来优化。

jstat -gc PID 1000 10 // 每秒执行一次, 执行10次
S0C:From Survivor区的大小。
S1C:To Survivor区的大小。
S0U:From Survivor区当前使用的内存大小。
S1U:To Survivor区当前使用的内存大小。
EC:Eden区的大小。
EU:Eden区当前使用的内存大小。
OC:老年代的大小。
OU:老年代当前使用的内存大小。
MC:方法区(永久代、元数据区)的大小。
MU:方法区(永久代、元数据区)当前使用的内存大小。
YGC:系统运行迄今为止的Young GC次数。
YGCT:Young GC的耗时。
FGC:系统运行迄今为止的Full GC次数。
FGCT:Full GC的耗时。
GCT:所有GC的总耗时。

jstat可以分析的数据:
    1)新生代对象增长的速率:观察每隔一段时间jvm中的Eden区对象占用变化。
    2)Young GC的触发频率和每次耗时:知道Eden的增长速率就能推断YGC的频率, YGC耗时 = YGC总耗时/YGC发生次数。
    3)老年代对象的增长速率、Full GC频率、Full GC耗时。

尽量让每次Young GC后的存活对象小于Survivor区域的50%, 都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率, 避免频繁Full GC对JVM性能的影响。

