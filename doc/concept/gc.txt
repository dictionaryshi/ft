1.对象的生命周期不同, 所以针对不同生命周期的对象可以采取不同的回收方式, 以便提高回收效率。(分代回收)

2.JVM堆内存主要由新生代、老年代、永久代构成。

3.新生代:对象在新生代中被创建, 其中很多对象的生命周期很短。每次新生代的垃圾回收(又称Minor GC)后只有少量对象存活, 所以选用复制算法。只需要少量的复制成本就可以完成回收。

4.新生代又分为三个区:一个Eden区, 两个Survivor区(一个Eden区和一个Survivor区默认比例是8:1)。

5.对象在Eden区中被创建, 当Eden区满时(发生Minor GC), 还存活的对象将被复制到两个Survivor区中的一个(From区)。当Eden区再次满时, Eden区存活的对象和From区的存活且不满足"晋升"条件的对象
将被复制到另外一个Survivor区(To)。

6.对象每经历一次Minor GC, 年龄加1, 达到"晋升年龄阈值"后, 被放到老年代。"晋升年龄阈值"的大小直接影响着对象在新生代中的停留时间。(默认值为15)

7.老年代:在新生代中经历了N次垃圾回收后仍然存活的对象, 就会被放到年老代, 该区域中对象存活率高。

8.老年代的垃圾回收(Major GC)通常使用"标记-清理"或"标记-整理"算法。

9.整堆包括新生代和老年代的垃圾回收称为Full GC。HotSpot VM里, 除了CMS之外, 其它能收集老年代的GC都会同时收集整个GC堆。

10.CMS回收器是一种以获取最短回收停顿时间为目标的回收器, 该回收器是基于"标记-清除"算法实现的。

11.活跃数据的大小是指, 应用程序稳定运行时长期存活对象在堆中占用的空间大小, 也就是Full GC后堆中老年代占用空间的大小。
    堆总大小==> 活跃数据 * 4倍
    年轻代==> 活跃数据 * 1.5倍
    老年代==> 总大小 - 年轻代

12.单次Minor GC时间更多取决于GC后存活对象的数量, 而非Eden区的大小。

13.如果应用存在大量的短期对象, 应该选择较大的年轻代。如果存在相对较多的持久对象, 老年代应该适当增大。

14.由于跨代引用的存在, CMS在Remark阶段必须扫描整个堆, 同时为了避免扫描时新生代有很多对象, 增加了可中断的预清理阶段用来等待Minor GC的发生。
只是该阶段有时间限制, 如果超时等不到Minor GC, Remark时新生代仍然有很多对象, 我们的调优策略是, 通过参数强制Remark前进行一次Minor GC, 从而降低Remark阶段的时间。

15.触发STW的Full GC:
    1)Perm空间不足(CMS默认情况下不会回收Perm区)

    2)老年代空间不足, 需要尽快回收老年代里面的不再被使用的对象。(CMS失败的原因)

    3)主动触发Full GC

    4)统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间。

