1.对象的生命周期不同, 所以针对不同生命周期的对象可以采取不同的回收方式, 以便提高回收效率。(分代回收)

2.JVM堆内存主要由新生代、老年代、永久代构成。

3.新生代:对象在新生代中被创建, 其中很多对象的生命周期很短。每次新生代的垃圾回收(又称Minor GC)后只有少量对象存活, 所以选用复制算法。只需要少量的复制成本就可以完成回收。

4.新生代又分为三个区:一个Eden区, 两个Survivor区(一个Eden区和一个Survivor区默认比例是8:1, 仅10%的内存处于闲置状态)。
复制算法的优点:消灭内存碎片。Eden区的加入同时提高了内存使用率。

5.对象在Eden区中被创建, 当Eden区满时(发生Minor GC), 还存活的对象将被复制到两个Survivor区中的一个(From区)。当Eden区再次满时, Eden区存活的对象和From区的存活且不满足"晋升"条件的对象
将被复制到另外一个Survivor区(To)。

6.对象每经历一次Minor GC, 年龄加1, 达到"晋升年龄阈值"后, 被放到老年代。"晋升年龄阈值"的大小直接影响着对象在新生代中的停留时间。(默认值为15)

7.老年代:在新生代中经历了N次垃圾回收后仍然存活的对象, 就会被放到年老代, 该区域中对象存活率高。

8.老年代的垃圾回收(Major GC)通常使用"标记-清理"或"标记-整理"算法。

9.整堆包括新生代和老年代的垃圾回收称为Full GC。HotSpot VM里, 除了CMS之外, 其它能收集老年代的GC都会同时收集整个GC堆。

10.CMS回收器是一种以获取最短回收停顿时间为目标的回收器, 该回收器是基于"标记-清除"算法实现的。

11.活跃数据的大小是指, 应用程序稳定运行时长期存活对象在堆中占用的空间大小, 也就是Full GC后堆中老年代占用空间的大小。
    堆总大小==> 活跃数据 * 4倍
    年轻代==> 活跃数据 * 1.5倍
    老年代==> 总大小 - 年轻代

12.单次Minor GC时间更多取决于GC后存活对象的数量, 而非Eden区的大小。

13.如果应用存在大量的短期对象, 应该选择较大的年轻代。如果存在相对较多的持久对象, 老年代应该适当增大。

14.由于跨代引用的存在, CMS在Remark阶段必须扫描整个堆, 同时为了避免扫描时新生代有很多对象, 增加了可中断的预清理阶段用来等待Minor GC的发生。
只是该阶段有时间限制, 如果超时等不到Minor GC, Remark时新生代仍然有很多对象, 我们的调优策略是, 通过参数强制Remark前进行一次Minor GC, 从而降低Remark阶段的时间。

15.触发STW的Full GC:
    1)Perm空间不足(CMS默认情况下不会回收Perm区)

    2)老年代空间不足, 需要尽快回收老年代里面的不再被使用的对象。(CMS失败的原因)

    3)主动触发Full GC

    4)统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间。

16.CMS(并发标记清除)的四个主要阶段:
    1)Init-mark初始标记(STW):该阶段进行可达性分析, 标记GC ROOT能直接关联到的对象, 所以很快。(单线程)
    2)Concurrent-mark并发标记:由前阶段标记过的对象出发, 所有可到达的对象都在本阶段中标记。
    3)Remark重标记(STW):暂停所有用户线程, 重新扫描堆中的对象, 进行可达性分析, 标记活着的对象。
    因为并发标记阶段是和用户线程并发执行的过程, 所以该过程中可能有用户线程修改某些活跃对象的字段, 指向了一个未标记过的对象。(在并发标记开始时不可达, 但是并行期间引用发生变化, 变为对象可达)
    这个阶段需要重新标记出这一类对象, 防止在下一阶段被清理掉, 这个过程也是需要STW的。特别需要注意一点, 这个阶段是以新生代中对象为根来判断对象是否存活的。
    4)并发清理, 进行并发的垃圾清理。

GC ROOTS:
    1)栈中局部变量引用的对象。
    2)方法区中的类静态属性引用的对象。
    3)方法区中常量引用的对象。
    4)JNI(本地方法栈)引用的对象。

垃圾回收器:
    1)-XX:+UseSerialGC:串行垃圾回收器。(年轻代/老年代垃圾回收器, 是单线程垃圾回收器, 老年代使用标整算法)
    2)-XX:+UseParNewGC:多线程并行年轻代垃圾回收器。(追求降低用户停顿时间)
    3)-XX:+UseParallelGC:多线程并行年轻代垃圾回收器。侧重于吞吐量。高效利用CPU, 适合后台运算。
    4)-XX:+UseParallelOldGC:多线程并行老年代垃圾回收器。侧重于吞吐量。高效利用CPU, 适合后台运算。
    5)-XX:+UseConcMarkSweepGC:并发标记清除老年代垃圾回收器。侧重短暂停顿。(CPU负担较大, CMS必须在老年代耗尽之前完成, 否则CMS失败将切换为SerialGC)
    CMS无法整理内存碎片, 往往老年代还有很大剩余空间, 但无法找到足够大的连续空间来分配给当前对象, 不得不触发一次Full GC来整理内存碎片。

CPU吞吐量 = 运行代码时间 / (运行代码时间 + 垃圾收集时间)

可达性分析法:所有和GC Roots直接或间接关联的对象都是有效对象。其它对象可以回收。

若Full GC后, 内存仍然不足, 则java.lang.OutOfMemoryError: Java heap space。

