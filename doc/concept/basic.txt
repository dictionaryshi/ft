1.编译Java文件, 有多少个类就生成多少个.class文件。

2.虚拟机识别的是.class文件(字节码文件),加载进内存中使用。

3.一个JAVA文件中只能有一个public修饰的类。而且java文件名必须与该类名称保持一致。

4.JAVA语言平台:javaSE, javaEE。

5.JRE(java runtime environment):JAVA运行环境, 包括JAVA虚拟机(Java Virtual Machine)和JAVA程序所需核心类库。

6.JDK(Java SE Development Kit):JAVA开发工具  + JRE。

7.关键字:被JAVA语言赋予特定含义的单词。(组成关键字的字母都是小写的)

8.常量:在程序执行过程中其值不可以发生改变(字面值常量和自定义常量)。

    *字面值常量:字符串常量, 整数常量, 小数常量, 字符常量, 布尔常量, null常量。

9.你聪明有人会说你心机重, 你靠的是努力有人会说你运气好, 你说自己天生乐观有人会说你虚假,
有时候, 你明明就是一杯白水, 却被人硬生生逼成了满肚子憋屈的碳酸饮料。人一生要遇见太多人,
即使有些话字字诛心, 也没必要活在他们的眼神里, 只要内心澄明, 就永远不用讨好一个不懂你的人。
爱生活, 爱Java。

10.1byte = 8bit  1k = 1024byte  1M = 1024k
1G = 1024M  1T = 1024G, 一个二进制位也叫bit位, 是计算机中的最小单位,
计算机中数据都是二进制来存储的。

11.JAVA数据类型分为两类:基本数据类型, 引用数据类型。

    1)引用数据类型:类, 接口, 数组。

    2)基本数据类型:数值型, 字符型(char), 布尔型(boolean)。

    3)数值类型:整数类型(byte, short, int, long), 浮点数类型(float, double)。

12.整数默认是int类型, 小数默认是double类型。

    byte:1个字节。
    short:2个字节。
    int:4个字节。
    long:8个字节。
    float:4个字节。
    double:8个字节。
    char:2个字节。
    boolean:1个字节。

13.JAVA具有块级作用域, 变量定义在哪个大括号中, 该大括号的范围就是该变量的作用域, 相同作用域不能出现同名变量。

14.不同数据类型之间运算时, 小类型默认转换成大类型。boolean类型不能参与运算。
byte, short和char参与运算时, 他们之间不能相互转换。(int, long, float, double)

15.大括号包围的部分叫做代码块。代码块执行完毕后, 定义在代码块中的局部变量的内存会被释放。
使用局部代码块可以提高程序性能。

16.对象:是类的具体表现形式。(类是图纸,对象是根据图纸做出来的零件)

17.成员变量在堆内存中, 局部变量在栈内存中。

18.private关键字:

    1)是一个权限修饰符。
    2)可以修饰成员变量和成员方法。
    3)被private修饰的成员, 只能在本类内被访问。

19.构造函数内存进行:堆中实体创建之后, 构造函数进栈, 对实体进行初始化, 然后弹栈。

20.成员方法始终呆在方法区内存中, 静态方法和静态变量始终呆在方法区的静态区中。(随类的加载而进入)

21.局部代码块:在方法中出现, 用于限定变量的生命周期, 提早释放变量所占内存, 提高内存的使用率。

22.构造代码块:在类中, 方法外出现。每次调用构造方法, 构造代码块都会执行, 并且在构造方法之前执行。用于将多个构造方法中相同的内容抽取出来。
在显示初始化之后执行。

23.静态代码块:就是加了static修饰的构造代码块。用于给类进行初始化, 在类加载时执行, 且只执行一次。

24.子类只能继承父类中所有 非私有的成员。(非private修饰)

25.final:用来禁止子类覆盖父类的功能。用来修饰类, 成员方法, 成员变量, 局部变量。(final修饰类:被修饰的类不能被继承)

26.final修饰成员方法:被修饰的成员方法, 不能被子类所重写。

27.final修饰成员变量:被修饰的成员变量不能被重新赋值, 且只能被赋值一次, 变为常量。(final修饰成员变量的初始化时机:在构造方法结束前)

28.堆内存空间分为两大区域:this区域和super区域(子类区域和父类区域)。

29.多态的好处:提高代码的扩展性, 前期定义的代码可以使用后期扩展的内容。(成员变量访问父类的,方法访问子类重写过的)

    权限修饰符:           public      protected         默认权限        private

	同一类中:				  √				√				√			    √     四种权限都可以访问。

	同一包子类和其他类:	      √				√				√                     私有成员其他类不允许访问。

	不同包子类:			  √				√									  不同包访问成员, 成员权限最少是protected。(还必须是子类)

	不同包其它类:			  √													  访问不同包成员, 权限必须是public。(非子类)

30.内部类的访问特点:

    1)内部类可以直接访问外部类的全部成员。(包括私有)

    2)外部类要访问内部类成员必须创建对象。(包括私有)

31.静态内部类访问外部类成员必须是static修饰的。(静态内部类是为了外界访问更方便)

32.局部内部类访问外部类方法的局部变量, 被访问的局部变量必须用final修饰。

33.局部变量会随着方法的调用完毕而消失。此时局部内部类的对象仍然在堆内存中, 依然要使用这个消失的局部变量。所以这个变量不能消失, 需要让该变量继续能使用,
final修饰后, 堆内存中存储的是一个常量, 可以通过反编译工具查看。

34.如果内部类被static修饰的话, 外部类一加载, 内部类就存在了。

35.数组既可以存储基本数据类型, 也可以存储引用数据类型。

36.int[] arr = new int[3], int[] arr是局部变量存在栈中, new int[3]是实例, 存在堆中,
在堆中分配了三个内存空间。数组中的元素就相当于类的成员变量。

37.数组一旦创建不能够增删元素。

38.二维数组的内存==>int[][] arr = new int[3][2];

    1)在栈内存为arr开辟内存空间。
    2)在堆内存中为二维数组的实体开辟一个内存空间。(3个索引的初始化值为null)
    3)在堆内存中为一维数组的实体开辟3个内存空间。(每个实体对应的2个索引初始化值为0)
    4)将每个一维数组的实体地址值赋值给二维数组的索引。
    5)将二维数组的地址值赋值给arr。(初始化完毕)

39.java.lang.String:

    1)public boolean matches(String regex) {} //判断字符串是否符合正则表达式的规则。
    2)public String[] split(String regex) {} // 分割字符串
    3)public String replaceAll(String regex, String replacement) {}

40.类的初始化时机:

    1)创建类的实例。
    2)访问类的静态变量, 或者为静态变量赋值。
    3)调用类的静态方法。
    4)使用反射方式来强制创建某个类或接口对应的java.lang.Class对象。
    5)初始化某个类的子类。
    6)直接使用java.exe命令来运行某个主类。

41.类加载器用来把.class文件加载到JVM的方法区内存中, 变成一个Class对象。

42.反射:JAVA反射机制是在运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法,
对于任意一个对象, 都能够调用它的任意一个方法和属性(包括私有),
这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

43.得到类加载器对象:this.getClass().getClassLoader();

44.类加载器的分类:

    1)根类加载器, 也被称为引导类加载器, 负责Java核心类的加载, 比如System, String等。加载JDK的JRE文件夹下的的lib目录下rt.jar中的类。

    2)扩展类加载器, 负责JRE的扩展目录中jar包的加载。在JDK中JRE的lib目录下ext目录中的所有jar包。

    3)系统类加载器, 负责在JVM启动时加载来自java命令的class文件(自定义jar), 以及classpath环境变量所指定的jar包和类路径中的jar。

45.JVM启动后, 引导类加载器随着JVM的启动被加载进内存, 接着引导类加载器加载标准类库, 然后引导类加载器将扩展类加载器加载进内存,
接着扩展类加载器将扩展类库加载进内存, 然后扩展类加载器再将系统类加载器加载进内存, 最后系统类加载器将自定义类和第三方jar包加载进内存中。

46.同一个类, JVM只会加载进内存一次。就是说Class对象唯一。

47.JVM认为相同类的特点:

    1)相同的.class文件。
    2)相同的类加载器。(不同的类加载器加载相同的.class文件, JVM会认为是不同的类)

48.类加载器的代理模式:当系统类加载器去加载一个类时, 它首先会让扩展类加载器去加载该类, 扩展类加载器又会让引导类加载器去加载该类,
如果系统类加载器的两个上级都没有加载成功, 那么再由系统类加载器本身去加载该类。

49.代理模式的好处:代理模式保证了JDK中的类一定是由引导类加载器加载的, 这就不会出现多个版本的类。

50.Tomcat提供了两种类加载器:

    *服务器类加载器:负责加载Tomcat目录下lib文件夹下面的类。
    *应用类加载器:负责加载项目webapps目录下WEB-INF\lib和WEB-INF\classes下的类。

    1)Tomcat会为每个项目提供一个应用类加载器。
    2)Tomcat提供的两个类加载器不会使用传统的代理模式, 而是自己先去加载, 如果加载不到, 再使用代理模式,
    这样的好处是可以使自己项目下的类优先被加载。(应用类加载器加载不到委托给服务器类加载器)

51.Tomcat加载类的优先级:

    1)WEB-INF\classes下的类(应用类加载器)
    2)WEB-INF\lib下的类(应用类加载器)
    3)Tomcat目录中lib目录下的jar(服务器类加载器)

