一个订单支付之后, 然后更改订单的状态为"已支付", 扣减商品库存, 给会员增加积分, 创建销售出库单通知仓库发货。

Try阶段:对各个服务的资源做检测以及对资源进行锁定。(订单状态修改为支付中, 库存扣减后记录冻结库存日志, 记录用户预增加积分日志, 仓库系统创建待确认出货单)
Confirm阶段:各个服务执行实际的操作。(订单状态修改为"已支付", 修改冻结库存日志的状态, 根据用户预增加积分日志给用户增加积分, 确认仓库的出货单)
Cancel阶段:如果任何一个服务的业务方法执行出错, 那么这里就需要进行补偿。(修改订单状态为"待支付", 根据冻结库存日志恢复库存, 根据预增加积分日志扣减用户积分, 将仓库出货单实效)

可靠消息服务最终一致性方案:
    1)上游服务发送一条消息给可靠消息服务。(包含上游服务要发送的消息体, 消息topic, 后续由可靠消息服务代理转发)
    2)可靠消息服务会把这条消息存储到自己的数据库里, 标记为待确认。
    3)上游服务开始执行本地数据库操作。根据执行结果再次发送消息给可靠消息服务。(确认/删除可靠消息服务上的待确认消息)
    4)如果是确认消息, 那么可靠消息服务就把数据库中的消息状态更新为"已发送", 同时将指定消息发往目的地。(这两个操作需要在一个事务中)
    5)下游服务就一直等着从MQ消费消息, 如果消费到了消息, 那么就操作自己本地数据库。
    如果操作成功了, 就反过来通知可靠消息服务, 然后可靠消息服务就会把消息的状态设置为"已完成"。
    6)可靠消息服务会有一个后台定时运行的线程, 不停的检查各个消息的状态。如果消息状态一直是待确认, 那么会回调上游服务询问执行结果, 进行相应处理。
    如果消息状态一直是"已发送", 此时可靠消息服务就可以再次尝试重新投递消息到MQ, 下游服务需要实现幂等。

